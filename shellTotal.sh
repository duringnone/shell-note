#!/bin/bash

 一、变量
	1、定义变量
		1) 定义变量,等号两边不得有空格,如: var='变量';
		2) 应用变量时,需要以$符号开头,如: echo $var;
		3) 分割符 {}, 如:${name}
		4) 只读变量,不能被更改,否则报错,关键字readonly;如: readStr='只读变量'; readonly $readStr;
		

	2、字符串
		1) echo ${str:1:4};	# 截取字符子串,参数: 操作数,起始位置,截取长度;注:字符长度从第0位开始
		2) echo ${#str}; # 获取字符串str的长度
		3) echo `expr index $str m`; # 查找字符m在字符串str中位置,被查找的为单个字符,字符位置从1开始计数,注:多次匹配只返回首次匹配的结果
		4) 双引号解析变量和转义符,单引号不解析变量和转义符(和PHP相似)
		5) 可以不加引号,也可以加单引号/双引号,推荐使用双引号
		6) -n	# 变量值是否为非空值,非空返回true,空返回false
		7) -z   # 变量值是否为空值,空返回true,非空返回false
		
	3、数组(只支持一维数组)
		1) arr=('ding' 'jiang' 'during' 'none'); # 定义数组,在小括号中定义,元素间以空格分隔
		2) echo ${arr[@]};	# 获取数组所有元素,同 echo ${arr[*]} 
		3) echo ${#arr[@]};	# 获取数组的元素个数
		4) echo ${#arr[2]};	# 获取数组第2个元素的字符长度
		5) echo $arr;	# 只获取第0个元素
		
	4、test 命令:
		作用:验证条件是否成立
		1) test命令测试:
			str1='ding';
			test -n $str1 && echo $str1;		# 若$str1不为空则输出$str1
			test 'ding' == $str1 && echo $str1; # 若$str1='ding',则输出$str1
			fileName='/mnt/www/shell/test-1.sh';
			test -f $fileName  && echo "文件 $fileName 存在";
			test -r $fileName && echo "$fileName 可读";
			test -w $fileName && echo "$fileName 可写";
			test -x $fileName && echo "$fileName 可执行";
	5、函数
		1) 函数命名： function 关键字可有可无，函数名后的 () 也可有可无,如: 
			function test() {} 
		或
			test () {}
		或
			function test {}
			
		注意: test {} 会报错 ;但是建议使用全写:
			function test() {}
		
		2) 返回值: 
			A) 函数若有返回值 ,则return返回值，否则可以在函数外调用函数,再 echo $?; ($? 作用: 获取最后一条命令的执行结果),如 3)A) 实例所示
			
			B) return返回值有数值的大小限制, 0~255循环计数,数值超过 255 ,重新从 0 开始算,所以如果返回超过255,就不能用这种方式,建议采用echo输出。
			
		3) 实例:
			A)通过 $? 获取函数返回值
				function func3 () 	# 定义函数
				{
					echo '第一个加数'；
					read num1;
					echo '第二个加数';
					read num2;
					return  $(($num1+$num2));
				}
				func3		# 调用函数
				echo "相加之和: $?"; # 获取func3函数执行结果;($? : 获取上一条命令的执行结果,正常返回0,出错返回1或非0值)
			
			B) 函数 return返回值,且验证函数return返回值取值范围, 实例:
				function func2() 
				{
					echo '第1个参数：'$1;
					echo '第9个参数：'$9
					echo '第9个参数：'${9}
					echo '第10个参数：'$10
					echo '第10个参数：'${10}	# ${n}表示函数第n个入参,当 n<10 时,${n}可以写成$n;
					echo "共有 $# 个入参"
					echo "所有入参的值依次是：$*"
					echo "所有入参的值依次是：$@"
				#	return '这是当前函数的入参信息';	# 非数值，reutrn会报错，可以用echo
				#	return '211';   # 输出：211
				#	return '255';	# 输出：255
							# 0~255循环计数，数值超过 255 ，重新从0开始算
				#	return '256';	# 输出：0
				#	return '257';	# 输出：1
					return '300';	# 输出：44

				}
				func2 'name' 2 3 4 5 6 7 8 9 'mail' '人生' 
				echo "func2函数的返回值：$?";
				
		4) 注意:
			A) 所有函数必须先定义再使用，shell与php不同，调用函数的代码位置必须函数定义的代码位置之后
			
			B) 报错/调试信息 须重定向到指定日志文件中，不要直接在 脚本/函数中 返回。不能向标准输出一些不是结果的东西（也就是说，不能随便echo一些不需要的信息），比如调试信息，这些信息可以重定向到一个文件中解决，特别要注意的是，脚本中用到其它类似grep这样的命令的时候，一定要记得 >>/dev/null 2>&1来空这些输出信息输出到空设备，避免这些命令的输出。
			
			C) >/dev/null 2>&1	# 表示:将标准输出和标准错误,都重定向到 /dev/null(即 空设备)中;  1: 标准输出;  2: 标准错误;  2>&1: 将1和2输入到同一文件中;  /dev/null:  linux的空设备,所有信息输入到/dev/null都不会被记录,所以一般日志文件都会输入到/dev/null
	
	6、包含文件夹符号: 口水点 或者 source;类似 include 关键字
		1)  . 或者 source ,都和文件路径名之间有一个空格
		2)  被包含的文件 可以没有执行权限，
		3) 实例:
			. ./info.sh				# 包含./info.sh文件
			# source ./info.sh		# 包含./info.sh文件
			echo '小帅哥信息：'$name -- $age -- $sex-- $hobby; # 变量在info.sh进行定义

			
			
二、输出,重定向(0-标准输入,1-标准输出,2-标准错误)
	1、echo 输出
		1) echo -n '输出内容';	# 输出,并取消换行(echo 默认自动换行)
		2) echo -e '\n解析转义符号';	# -n 解析输出内容中的转义符号和linux命令


	2、重定向(0-标准输入文件,1-标准输出文件,2-标准错误文件,常用于执行脚本和记录日志信息)
		0)注意: 
			A) 输入重定向 和 输出重定向 中的 输出,输入是相对于 shell命令而言的
			
			B)下列 command 均代指linux命令 
		
		1) command < test.sh	# 输入重定向,让test.sh文件内容执行command(需在linux命令窗口执行)
			A) 实例1:
				cat   < ./log/stdIn.sh	# 输入重定向,读取stdin.sh文件内容
			B) 实例2:
				cat < ./log/stdIn.sh > ./log/outFile.sh	# 代码执行顺序：从左至右；先重定向输入，再重定向输出；将重定向输入的内容输出到重新输出的文件中
				
		2) command > test.sh	# 输出重定向(覆盖文件内容)		
		
		3) command >> test.sh	# 输出重定向(内容追加到文件末尾) 
		
		4) command >> test.sh 2>&1;	# 将标准输出和标准错误,一起追加到test.sh文件末尾
		
		5) 深入理解： 
		每个Unix/Linux命令运行时都会打开三个文件：
			A) 标准输入文件(stdin):stdin 的文件描述符为0，Unix程序默认 从stdin读取数据
			
			B) 标准输出文件(stdout):stdout 的文件描述符为1，Unix程序默认 向stdout输出数据
			
			C) 标准错误文件(stderr):stderr 的文件描述符为2，Unix程序会向stderr流中写入错误信息
		
		 6) 注意: command >> fileName 2>&1 	# 将stdout 和 stderr 合并后 追加到fileName文件中
		 
		 7) 标准错误和标准输出 合并后重定向 追加到同一文件,实例:
			  file=`date '+%Y%m%d'`.log; 
			  echo `ps -ef | grep php` >> /mnt/www/shell/log/$file 2>&1       # 命令执行结果需要用 echo 打印出来
		      echo $(date) >> /mnt/www/shell/log/$file 2>&1 # $() 和 `` 的作用: 都是解析linux,如:$(date); ## 获取时间

	
	3、 printf输出(类似C语言的printf函数)
		格式: printf format-string [arguments]	# format-string:格式控制字符串;arguments:参数列表
		1) 替代格式符: %d %c %s %f , 如: %-10s指一个宽度10个字符(-表示对齐,任何字符都会被显示在10个字符宽的字符内,若不足则自动以空格填充,若超过也会将内容全部显示出来); 再如:%-4.2f指格式化为小数,其中.2指保留2位小数
		
		2) 实例:
			printf "%s\n" ding jiang;	# 分两行输出:ding  jaing, %s\n表示输出一个字符且换行,字符以空格间隔;一个格式符,多个参数,则表示所有参数都使用这种格式输出,注意格式符为: %s\n , 而不是 %s
		
		3) 实例:
			printf "%s %s %s\n" this is my file that is used to be test; # 每3个字符为一行输出,并换行,整个双引号中的内容为格式符; s% s% s% 表示三个字符
		
		4) 注意:printf需要手动加换行,echo 可以自动换行
		
	
	4、转义符号:
		1) \a	# 警告字符;
		2) \b	# 后退;
		3) \c	# 抑制;
		4) \f	# 换页;
		5) \n	# 换行;
		6) \r	# 回车;
		7) \t	# 水平制表符;
		8) \v	# 垂直制表符;
		9) \\	# 反斜杠字符;
		10) \ddd	# 表示1到3位数八进制值的字符,仅在格式符中有效;
		11) \0ddd	#表示1到3位的八进制字符
	
	4、执行指定区域的命令,定界符
		注意:
		1) 定界符有开头结尾两部分组成,两处定界符必须相同;
		2) 定界符不区分大小写;
		3) 结尾的那个定界符必须顶格写;
		4) 后面也不能有任何字符,包括空格和 tab 缩进
		5) 实例1:
			#cat << EFO
			#       '人生若只如初见'
			#    '何事秋风悲画扇'
			#  '等闲变却故人心'
			#       '却道故心人易变'
			#               -- 纳兰容若
			#EFO

		6) 实例2:	
			#正确写法, 前定界符: dingjiang, 后定界符: dingjiang
			#cat << dingjiang
			#       '人生若只如初见'
			#    '何事秋风悲画扇'
			#  '等闲变却故人心'
			#       '却道故心人易变'
			#               -- 纳兰容若
			#dingjiang
		
		7) 实例3:
			# 错误写法, 定界符前后不一致,前定界符: ding, 后定界符: dingjiang
			#cat << ding
			#       '人生若只如初见'
			#    '何事秋风悲画扇'
			#  '等闲变却故人心'
			#       '却道故心人易变'
			#               -- 纳兰容若
			#dingjiang



三、文件			
	1、shell 传递参数
		1) /test.sh 'jiang.ding' 22 '男'	# 执行test.sh文件,并带有三个参数,参数间空格隔开
		2) $0		# $0指的是执行文件名, 如: 1) 命令中的执行文件名是test.sh
		3) ${n}		# 指的执行文件后跟的第n个参数,当 n=0时,表示当前执行文件路径名,如 2)所示; 当 n<10 时,可写成$n,但建议使用${n}
		4) $#		# 此次传递的参数个数,如 1)中的 $# 为3
		5) $*		# 获取此次传递的所有参数;以 1) 为例输出:'jiang.ding' 22 '男'  
		6) $@		# 获取此次传递的所有参数;输出同 $*
		7) $$		# 获取脚本运行的当前进程ID
		8) $!		# 获取脚本运行的最后一个进程ID
		9) $-		# 显示shell使用的当前选项(set命令的规则参数选项)
		10) $?		# 显示最后命令的退出状态,或函数的返回值(注:一般正常/成功为0,非正常/失败为1)
		11)  $@ 和 $* 的区别: $* 相当于传递了一个由多个参数拼接后的字符串, $@相当于传递了多个参数字符串
	
	2、文件权限操作
		介绍: 0777,中的0指的是当前用户对文件的操作权限
		1) SUID->4,缩写S		#  Set user ID,具有该权限的文件会在其执行时，使调用者暂时获得该文件拥有者的权限
		2) SGID->2,缩写S		#  Set Group ID,具有该权限的文件会在其执行时，使调用者暂时获得该文件所属用户组的权限
		3) SBIT->1,缩写T		# Sticky Bit，目录拥有SBIT权限时,用户所建立的文件，只有该用户自己和root可以删除，其他用户均不可以

		4) chmod 4744 文件名   	# 显示: -rwSr--r--
		5) chmod 2744 文件名	# 显示: -rw-r-Sr--
		6) chmod 1744 文件名	# 显示: -rw-r--r-T
		7) chmod 7744 文件名	# 显示: -rwSr-Sr-T
		8) chmod 7777 文件名	# 替代执行文件属性x,显示: -rwsrwsrwt
	
	3、文件操作符
		1) -b 	# 检测文件是否为块设备文件,若是则返回true,否则返回false
		2) -c	# 检测文件是否为字符设备文件
		3) -d	# 检测文件是否为目录
		4) -f	# 检测文件是否为普通文件(不是目录,也不是设备文件)
		5) -g	# 检测文件是否设置SGID位,只有root和文件所属用户组有操作权限(读/写/执行)
		6) -k 	# 检测文件是否设置了粘着位(Sticky Bit),粘着位可以保护目录不被删除,但是具有w权限的用户可以更改目录下文件内容;文件目录才有粘着位,粘着位只对root和文件所有者有效
		7) -p	# 检测是否为有名管道; A) 无名管道: 用于父进程和子进程间的通信; B) 有名管道: 用于同一系统任意两个进程间通信
		8) -u	# 检测是否设置SUID位,SUID是设置文件当前用户的权限
		9) -r 	# 文件是否可读
		10) -w	# 文件是否可读
		11) -x	# 文件是否可执行; 设置SBIT的文件仍然不可执行???
		12) -s	# 文件是否为空(即文件大小是否大于0),不为空返回true
		13) -e	# 检测文件/目录,是否存在
		
	4、文件内容操作
		1) 命令简介:
			cat 	#从上到下显示文件所有内容 (重用 -n,-b)
			tac		# 从下到上显示文件所有内容
			nl 		# 显示文件所有内容和控制行号显示(cat 也可以)
			more 	# 一页一页翻动
			less 	# 一页一页翻动
			head 	# 从上到下显示固定行数量的内容(默认显示10行)
			tail 	#从下到上显示固定行数量的内容(默认显示10行)
		
		2) cat 查看文件内容 [(从上到下)正序显示]
			格式：
				cat [option] 文件路径 
			常用参数：
				A) -b  # 原样输出文件内容,并给所有行标注行号,不包括空白行;  
				B) -n  # 原样输出文件内容，并给所有行标注行号，包括空白行
				
				
		3) tac 查看文件内容  [(从下到上)逆序显示], 提示: tac 刚好是 cat 反过来
				A) 格式: 
					tac [option] 文件路径
				B) 常用参数:
		
		4) nl	查看文件内容的行号
			 格式：
				nl [option] 文件路径名	
			 
			 nl有三种模式:
				 A) -n(行号显示位置),
					-n ln	# 行号显示在屏幕最左边,行号不加0		
					-n rn	# 行号显示在屏幕最左边,行号不加0		
					-n rz	# 行号显示在屏幕最左边,所有行号为6位数,前以0拼接,如:78->000078 
				
				B) -b(行号显示模式),  
					-b a 	# 显示所有行的行号,包括空白行		
					-b t 	# 显示所有非空白行的行号,即空白行行号不显示		
				C)	-w(行号栏位占用的位数)
		
		5)  more	分页显示文件内容
			格式:
				more 文件路径名
			可在more命令下执行以下命令:
				命令	功能
				Enter	# 向下翻一行	
				/字符	# 向下查找字符串
				:f 		# 立刻显示当前光标所处行号,并显示当前文件路径名
				b 		# 往回翻(相当于上一页)
				ctrl+b	# 往回翻(相当于上一页)
				q		# 退出more命令	

		6) head 显示文件内容，行数从上到下计算，默认显示10行
			格式:
				head [-n number] 文件路径	# number 表示显示的行数, 行数从上到下计算, 默认显示10行
		
		7) tail 显示文件内容，行数从下到上计算，默认显示10行
			格式:
				tail [-n number] 文件路径	 # number 表示显示的行数, 行数从下到上计算, 默认显示10行
	
	5、linux的文件链接
		链接的概念:
			1) Linux 链接分两种: 一种为硬链接（Hard Link），另一种为符号链接（Symbolic Link）。默认情况下，ln 命令产生硬链接。
		
			 2) 硬连接:
				硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。	硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。
			3) 软连接:
				另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。
			4) 实验方法(检测硬链接和符号链接(软连接)区别的):
				touch f1	# 创建文件f1
				ln f1 f2	# 给文件f1 创建一个硬链接f2
				ln -s f1 f3	# 给文件f1 创建一个软连接f3

				ls -li		# 列出当前目录下所有文件,以及文件属性和 文件的 索引节点号 (Inode Index)

			5) 注意：
				 A)  f1 和 f2 索引节点号相同, 即二者指向的是同一个 Inode Index,当删除f1时,访问f2不受影响,访问f3失效(因为f3的数据中存放的f1的地址链接,而不是文件内容)

			6) 总结: 
				1)  每个 Inode Index 指向一个数据块,相同的索引节点号的两个文本本质上是同一个文件
				2)  每个文件由两部分组成: 文件名 和 文件索引节点(Inode Index),每Inode Index 指向一个数据块,一个数据块可以对应多个文件名,如 f1 和 f2 就指向同一个 Inode Index; 当数据块内容被修改时,同一数据块对应的所有文件内容都被同一修改,(类似: PHP中的引用传参,多个变量指向同一内存块,任一变量值改变,则内存块内容改变,但是变量别名删除,内存块内容仍然存在,只有当所有变量名删除,内存块才会被清空)		
				3) 硬链接f2 链接的是f1的数据块(文件内容),软链接f3相当于是快捷方式,真正访问的是f1文件->f1数据块
			
			
	
	
四、流程控制,循环
	1、if/else判断: [] 的两边内侧和中括号内的字符之间要有一个空格,否则报错
			实例:
				num=18
				if [ $num -ge 10 -a $num -le 15 ];then
					echo '大于等于10 且 小于等于15';
				elif [ $num -le 10 -o $num -ge 20]
					echo "大于等于20 或 小于等于10";
				else
					echo "这就是num的值:$num";
				fi
	2、switch/case: 
		1) case 中的 *) => "default:" 
		2) case 中的 ;; => "break;" 
		3) case 以 "case" 开头 ,以 "esac" 结束, 且 "case","esac"必须成对出现
		4) 语法:	
			case 变量 in
				变量/常数)
					command
				;;		
			esac
	
		5) 实例:
		#echo '请输入一个数字,可以1~4,或其他: ';
		read number	# 声明可读变量，执行此行命令时,输入变量值,回车,即可将变量值赋给可读变量number
		case $number in
			1)			# 类似PHP中的 "case 1:"
				echo '输入了---'$number;
			;;			# 类似PHP中的 "break;"
			2)
				echo '输入了---'$number;
			;;
			3)
				echo '输入了---'$number;
			;;
			4)
				echo '输入了---'$number;
			;;
			*)		# 类似PHP中的 "default:"
				echo '输入了范围以外的---'$number;
			;;
		esac		# case 的结束标志符号,与case成对出现


			
	3、for 循环
		1)格式: 
			for 变量名 in 值1 值2 值3...	# 或者使用: for 变量名 in ${arr}	## arr=(值1 值2 值3 ...);
			do
				echo $变量名;
			done
		
		2) for 循环一个范围内的数
			结构:
				变量赋初值;循环终止的条件;自增/自减
			注意:
				for 循环中的变量不需要加$符号，但是在shell使用变量时须加上$,如下的$i
			实例:
				for ((i=1;i<=10;i++))
				do 
					let s=4*i;	# 乘法(数值计算)
					echo $s;
				done
		3) 遍历数组
		 注意: 
			A) for循环的操作数必须以空格隔开，无法直接操作数组(直接操作数组<=>操作数组的第0个元素)
			
			B) 遍历数据，切记必须使用{}分隔符，否则只能取第0个元素
			
			C) 实例:
			arr=('丁江' 'man' '22' '爱好女');
			#for j in ${arr[@]};    # 正确语法
			for j in ${arr[*]};     # 正确语法
			#for j in $arr[3];      # 错误示例: $arr[3]否则识别为$arr[0],和[3] ,必须使用分隔符{}
			# for j in ${arr};      # 注意: ${arr} <==> ${arr[0]},只取第0个元素
			do
					echo $j
			done

		4) for 循环某个范围内的数字，
			 注意:
				seq n, 可以取1到n的整数，但是n为百万级别数时，会有问题，n不再是阿拉伯数字，而是科学计数
			A) 实例代码:
				for num in $(seq 10)	# 正确语法
				for num in $(seq 1 10)	# 正确语法
				#for num in `seq 10`	# 正确语法
				#for num in ((seq 10))	# 错误语法
				do
					echo 'seq函数范围内的数有---'$num;
				done
		
		5)  for 无限循环
			A) 实例1: 
				for((i=2;i<=0;i++))		# 循环条件恒不成立
				do 
					echo $i
				done
			B) 实例2:
				set m=3;
				for((n=0;n<10;))	# 可以不在(())中，但是初始值+终止条件 必须存在	
				do
					echo $m;
					let m--;	# 自减
				done
	
			
	4、while 循环
		1)实例: 
			age=21;
			while(($age<=25))	# 正确语法
			#while[[$age<=25]]	# 错误的语法
			#while$($age<=25)	# 错误的语法
			do
				echo '年龄:'$age;
				let age++;	# 正确语法
			#	let "age++";	# 正确语法
			#	let `age++`;	# 错误语法
			done
		
		2) while循环读取键盘信息
			操作: 运行脚本文件后，直接键盘输入内容:dingjiang,回车则输出: dingjaing
			代码:
				echo -n '测试while循环读取键盘信息：';
				while read FLIM		# FLIM 就是从键盘获取的值 
				do 
					echo '===>' $FLIM ;	
				done
				
		3) while 无限循环
			1) while无限循环
			实例:
				count=0;
				while true
				#while :		# 正确语法
				#while((1))		# 正确语法
				#while 1		# 错误语法
				#while(('aaaa'))		# 正确语法
				do 	
					echo '无限循环'$count;
					let count++;
				done

	5、until 循环 (与while循环相反，while是条件为true时，执行循环体，循环条件为false时，终止循环)
		1) 格式:
			set x=2;
			until [ ! $x -lt 10 ]	# 正确语法
			#until false		# 正确语法
			#until :		# 错误的语法
			do
				echo $x;
				let x++;
			done


		2) 例子:
			a=0;
			until [ ! $a -le 10 ]
			do
				echo $a;
				let a++;
			done
				
	6、跳出循环
		1) break: 跳出所有循环 (本层循环体)
		2) continue: 跳出本次循环 (本层循环体的一次循环)
		3) break 中断循环实例:			
			while :			# 当输入的数字不在1~4范围内，则跳出无限循环
			do
				echo '测试break：';
				read break;		# 可以用系统关键字 break 作为变量名，但不建议这么做
				case $break in
					1|2|3|4)	# 使用 按位或 符号 表示多种情况,输出同一内容	
						echo '这是范围的数----'$break;
					;;
					*)
						echo '这是超出范围内的数----'$break;
						break;
					;;
				esac
			done


		4) continue 中断循环实例:
			while :			# 当输入的数字不在1~4范围内，则跳出无限循环
			do
				echo '测试continue：';
				read con;
				case $con in
					1|2|3|4)
						echo '这是范围的数----'$con;
					;;
					*)
						echo '这是超出范围内的数----'$con;
						continue;
						echo 'boy，game 结束';
					;;
				esac
			done

					
五、运算		
	1、运算符号
		1)  + - * / 	加、减、乘、除
		2)  % 	取余
		3)  & | ! ^  与、或、非、异或
		4) 优先级: 非>与>或; 	(! 逻辑非, -a 逻辑与, -o 逻辑或)
		
	2、算术运算
		1) 加/减运算
			A) expr 加/减号和两个加数/减数之间必须留有空格,不能写成 1+2 , 必须写成 1 + 2 ,
			B) 比较两个数字时m,n时，即$m == $n，两数字相等返回true,打印输出1，不相等返回false,打印输出0 

		2) 乘/除运算
			A) expr 乘法运算时,必须使用转义后的乘号 \*,如: product=`expr $var1 \* $var2`;
			
		
	3、逻辑运算
		1) 关系运算符
		数值比较: 以下比较符号,满足为真,不满足为假
			A) -eq 	# 等于
			B) -ne 	# 不等于
			C) -gt 	# 左边大于右边 
			D) -lt 	# 左边小于右边
			E) -ge 	# 左边大于等于右边
			F) -le 	# 左边小于等于右边
			G) !=  	# 不等于
			H) -a  	# 逻辑与
			I) -o  	# 逻辑或
			J) &&  	# 逻辑与
			K) ||  	# 逻辑或
			L) &   	# 按位与,即位运算与
			L) |   	# 按位或,即位运算或
			M) -n	# 变量值是否为非空值,非空返回true,空返回false
			N) -z   # 变量值是否为空值,空返回true,非空返回false
			
		2) 逻辑运算时,符合要求则返回true,如 10 -eq 20,返回false,因为10不等于20
		3) 位运算的优点: 位运算比正常十进制数计算效率高的多,位运算是二进制运算,位运算会直接在内存中进行二进制数操作;正常的十进制运算需要多步转化,不是直接在内存中操作;
			A) 逻辑与实例:
				将 & 两边的十进制数转化成二进制数,再进行二进制与计算,如: 3 & 6 => 0011 & 0110 = 0010 ,再转化为十进制数: 2;

	
六、正则(常用于grep和egrep)
	基本正则表达式元字符,分为四种:
	1、字符匹配
		1) .:匹配任意单个字符,类似于通配符中的？
		2) []:匹配指定范围内的任意单个字符
		3) [^]:匹配指定范围外的任意单个字符
		4) [:digit:],[:lower:],[:upper:],[:space:]
		5) [:alpha:],[:alnum:],[:punct:]


	2、匹配次数:	用于要指定匹配其出现次数的字符的后面，用于限制其前面的字符出现的次数，默认工作于贪婪模式：
		1) *：匹配其前面的字符任意次， 0，1，多次
		2) .*：匹配任意长度的任意字符
		3) \?：匹配其前面的字符0次或者1次，
		4) \+：匹配其前面的字符1次或者多次，前面的字符至少出现1次
		5) \{m\}:匹配其前面的字符m次
		6) \{m,n\}:匹配前面的字符至少m次至多n次
		7) \{0,n\}:至多匹配n次
		8) \{m,\}:至少匹配m次

	3、位置锚定
		1) ^:行首锚定：用于模式的最左侧
		2) $:行尾锚定：用于模式的最右侧
		3) ^patten$:用patten来匹配整行
		4) ^$:空白行
		5) ^[[:space:]]*$:

		6) \<或者\b:词首锚定，用于单词模式的左侧
		7) \>或者\b：词尾锚定，用于单子的右侧
		8) \<patten\>:匹配完整的单词

	4、分组及引用
		1) :将一个或者多个字符捆绑在一起，当作一个整体进行处理
		2) 分组括号中的模式匹配到的内容会被正则表达式引擎记录于内部的变量中，
		3) \1:模式从左侧起，第一个左括号以及与之匹配的右括号之间的模式匹配到的字符
		4) \2:模式从左侧起，第二个左括号以及与之匹配的右括号之间的模式匹配到的字符
	
	5、egrep 和grep -E一样,egrep 和 grep的功能几乎一样，但是使用的是拓展的正则表达式,拓展正则表达式没有.*了，然后就是少了使用\, 比如说
		1) ？表示 0次或者1次,在grep里头要写\?
		2) +：其前面的字符至少出现1次, grep中则要写 \+
		3) {m}:其前的字符出现m次, grep中要写 \{m\}
		4) egrep中加入了或的一个逻辑
			a|b:a或者b
			C|cat:C或者cat
			(C|c)at:cat或者Cat
			
			
七、Linux拓展命令

##############------- 1、用户和用户组命令 -------#############
	用户和用户组命令,以及账号信息(用户信息,用户组信息,用户密码):
		命令		作用
		useradd		添加新用户
		usermod		修改用户信息(?????)
		userdel		删除用户
		groupadd	添加新用户组
		groupmod	修改用户组
		groupdel	删除用户组
		passwd		修改用户密码(root用户不用输入旧密码)
		
	## 注意:
	##	1) 因为命令有多个参数,且每个参数都有参数值,所以格式为: command -var1 value1 -var2 value2 -var3 value3 ... value	, 如: useradd -c '这是duringnoe用来测试的' -g testUser -d /home test001 
	## 	2) usermod 可以修改useradd 中的所有属性; groupmod同理
	##	3) UID 和 GID的取值范围: (500,60000), 即501~59999


	# 1、用户 
	## useradd	添加
	### 参数:
	#	-c	# comment 指定一段注释
	#	-d	# 目录 指定用户家目录,若此目录不存在,则需要使用-m创建家目录（家目录又名主目录）
	# 	-g	# 用户组 指定用户所属用户组
	# 	-G	# 用户组,指定用户附加的用户组; 注:一个用户可以属于多个用户组,但只有一个主要的属组(登录时默认),其他属组均为附加用户组
	#	-s	# Shell文件 指定用户的登录执行文件; 注:每个用户都会有个登录执行文件,参照文件/etc/passwd 
	# 	-u	# 用户ID,若同时使用-ou 表示不仅指定用户ID,并且重复使用用户ID(即用户ID已存在时,但是新用户仍然使用原用户ID)

	总结: 
	###	1) 创建用户时,若未指定用户组,则默认创建与用户名同名的用户组, 如: useradd test001, 则同时创建用户组test001
	###	2) useradd -c '测试账号001' -g testUsers -G testUsers,customs,tests -d /home/ test001  # 指定用户组testUsers, 同时添加多个附加用户组,附加用户组名间用逗号隔开

	## usermod	修改
	### 参数:
	#	usermod -c '修改后的测试账号005' -g test006 -G test003 -d /utest005 -s /sbin/nologin test005	# 可以修改用户的所有属性(useradd命令中有介绍)

	## userdel	删除
	### 参数:
	#	userdel test005		# 删除用户test005,注: 只删用户在文件/etc/passwd 信息,不会删除 /etc/group 中信息 和 用户家目录 /home/test005
	#	userdel -r test005	# 删除用户test005所有信息, (删除/etc/passwd, /etc/group, /etc/shadow 和 家目录/home/test005)

	# 2、密码
	##  passwd [option] 用户名	修改用户密码(即口令)
	### 参数:
	#	-l	# 锁定口令,即禁用账号,注:lock
	#	-u	# 口令解锁,注:unlock
	#	-d	# 使账号无口令,即无密码
	#	-f	# 强迫用户下次登录时修改口令
	#
	# 格式: 
	#	passwd [option] 用户名
	# 总结:
	##	1) passwd [用户名]	#若默认用户,则修改当前用户密码, 如 passwd test001 
	##	2) 密码规则(取值范围): 0-9,a-z,A-Z, 这三者的随意组合; 但是不得有特殊字符
	## 	3) passwd -d test001	# test0011下次登录时,不再需要密码
	## 	4) passwd -l test001	# 锁定用户test001,解锁: passwd -u test001
	

	# 3、用户组
	## groupadd	添加
	### 参数:
	#	-g	指定新用户组的组标识号(GID)
	#	-o	一般和-g一起用,表示新用户组的GID 可以和已有的用户组GID相同,注: over
	#
	# 总结:
	##	1) groupadd -g 522 用户组名	# 新建用户组名,如: grounp testUsers (新建用户组testUsers)
	##	2) groupadd -g 505 -o 用户组名	# 新建用户组名,指定GID,且可以使用已存在的GID
	##

	## groupmod	修改
	### 参数:
	#	参数与groupadd参数一致,可以修改上述所有属性
	#
	#	groupmod -g 506 -o test0823  # 其中506为修改后的GID

	## groupdel	删除
	### 参数:


	## newgrp 	切换用户组
	#	
	#	newgrp	testUsers	# 切换用户组,切换到testUsers 用户组;注: testUsers必须为用户的主组或附加组,一般用于多用户组用户


	# 二、 文件介绍		(文件作用和文件内容格式)
	# 	文件路径	作用			文件文件内容格式
	# 	/etc/passwd	存放用户信息		
	# 	/etc/shadow	存放用户密码(加密后)	
	# 	/etc/group	存放用户组信息		
	#
	## 总结: 三种文件中分隔符号都是分号

	# 1、/etc/passwd	存放用户用户名信息
	# 格式:
	#	testxxx:x:503:504:测试账号xxx:/home/testxxx:/bin/bash
	#	用户名:密码:用户ID:用户属组ID:注释:用户家目录:用户登录后的shell执行文件
	# 总结:
	##	1) 若用户拥有多个用户组,则/etc/passwd只显示一个用户属组ID(此用户组登录后默认),更换属组需要手动切换(执行: ) 
	##	2) 在创建用户时,若未指定用户组(指定的用户组必须已存在,否则报错),则默认建立与用户名同名的用户组,如 useradd test001 ,则建立一个test001用户,同时建立test001用户组
	##	3) 为了安全保密, 密码为 x 或者空, 加密后的密码存放在文件 /etc/shadow
	##	4) 登陆后shell文件: /bin/bash	表示该用户可登陆; 若为 /sbin/nologin ,表示用户无登陆权限,即不可登陆
	##

	# 2、/etc/shadow	存放用户密码
	# 格式:
	#	test002:!!:17765:0:99999:7:::
	#	用户名:口令:最后一次修改时间：最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志
	#
	# 例子:
	#	test001:$6$.H5rMd0K$JnY5CJxA9MAcb7bMj8n55LVi1qjqqk0VwJvUeUPLuWrWEle7uL3vNrdcp8OvQ90v3XsEgd6yP.2TA/eOJqpfJ.:17766:0:99999:7:::	# 存放了加密后口令
	#  	testxxx::17766:0:99999:7:::	# 口令被删除时，口令那列为空
	#  	test002:!!:17765:0:99999:7:::	# !! : 表示初始化口令,还未设置
	
	# 总结:
	##	1) 口令: 是加密后的用户口令;若为空，则该用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。注: CentOS6.8Linux系统登录密码不得为空
	##	2) 最后一次修改时间: 从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。
	##	3) 最小时间间隔: 指两次修改口令之间所需的最小天数。
	##	4) 最大时间间隔: 指口令保持有效的最大天数。
	##	5) 警告时间: 的是从系统开始警告用户到用户密码正式失效之间的天数。
	##	6) 不活动时间: 指用户没有登录活动但账号仍能保持有效的最大天数。
	##	7) 失效时间: 给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。

	# 3、/etc/group
	# 格式:
	#	testUsers:x:504:testxxx,test0823,test0823C
	#	组名:口令:组标识号:组内列表
	#
	# 总结:
	##	1) 组内用户列表: 同一用户组中的用户名,以逗号隔开
	##	2) 组标识号: 即GID

	# 三、批量添加用户，批量添加密码
	# 流程:
	#	1) 创建newUsers.txt 存放多个用户信息(文件内容格式参照/etc/passwd); newPasswd.txt 存放多个新用户对应的密码,格式: 用户名1:密码(明文), 有多少用户,就写多少行
	#	注意: 以下命令均在root用户下执行
	#	2) /usr/sbin/newusers < /mnt/www/shell/userGrounp/newUsers.txt   # 将用户信息导入/etc/passwd文件中	
	#	3) pwunconv  	 # 将 /etc/shadow 产生的 shadow 密码解码,然后回写到 /etc/passwd 中，并将/etc/shadow的shadow密码栏删掉。这是为了方便下一步的密码转换工作，即先取消 shadow password 功能
	#	4) /usr/sbin/chpasswd < /mnt/www/shell/userGrounp/newPasswd.txt   # 创建用户密码，chpasswd 会将经过 /usr/bin/passwd 命令编码过的密码写入 /etc/passwd 的密码栏。
	#	5) /usr/sbin/pwconv	# 将密码编码为 shadow password，并将结果写入 /etc/shadow。
	#
	# ？？？shadow的加密算法


	# 四、其他命令
	## ls [option] [文件目录名(非文件),默认为当前目录]	# 列出目录下所有文件信息
	# 常用命令:
	#	ls -lh 			# 列出目录下所有文件,并显示文件容量,单位K
	#	ls --full-time		# 列出目录下所有文件,并显示完整创建时间
	# 	ls -li			# 列出目录下所有文件,并显示文件inode编号
	#	ls -ln	  		# 列出目录下所有文件,并显示文件所属用户id和用户组id


	## groups 	# 查看所有用户组信息,如: groups testUsers (查看用户组testUsers信息,默认查看所有用户组)
	## id 		# 查看用户信息,如: id test001 (查看test001用户信息,默认查看所有用户)


################------- 2、磁盘空间管理 -------#############
	 #磁盘空间管理
		df		# 列出文件系统的整体磁盘使用量
		du 		# 检查磁盘空间使用量
		disk	# 用于磁盘分区
		stat  	# 查看文件inode 信息
		fdisk 	# 磁盘分区
		fsck	# 磁盘检测,(file system check)
		mkfs	# 磁盘格式化
		mount 	# 磁盘挂载
		umount	# 磁盘卸载

	# 磁盘空间命令
	# 1、 df 检查文件系统的磁盘空间占用情况
	# 语法:
	##	df [option] [目录或文件名]	
	#
	# 常用参数:
	#	 -a	列出所有的文件系统,包括系统特有的/proc 等文件系统
	# 	 -k	以KBytes 的容量单位显示各文件系统
	#	 -m	以MBytes 的容量单位显示各文件系统
	#	 -h	以人们较易阅读的GBytes,MBytes,KBytes 等格式自行显示
	#	 -H	以 M=1000K 取代 M=1024 的进位方式
	#	 -T	显示文件系统类型,连同该partition 的filesystem 名称(例如ext3)也列出
	#	 -i	不用硬盘容量,而以inode 的数量来显示
	#
	#  总结:
	##	1) df	# 默认显示当前文件系统的使用情况(文件系统名-总容量-已用容量-可用容量-已用百分比-系统挂载路径) 
	##	2) df -hm	# 显示以 MBytes 显示的文件系统使用情况; 注: df 后可跟多个参数,若两个参数意义重复,后面参数的内容会覆盖前面的内容, 
	##	3) df -ai	# 所有文件系统,同时显示他们的 文件索引号信息, inode 数量使用情况 

	# 2、 df 检查文件系统的磁盘空间占用情况
	# 语法:
	##	du [option] [目录或文件名]	
	#	 -a	列出所有的文件系统,包括系统特有的/proc 等文件系统
	# 	 -k	以KBytes 的容量单位显示各文件系统
	#	 -m	以MBytes 的容量单位显示各文件系统
	#	 -h	以人们较易阅读的GBytes,MBytes,KBytes 等格式自行显示
	#	 -s	列出总量，而不列出每个子目录占用容量
	#	 -S	只显示各个子目录的占用容量,不显示目录总容量
	#	 
	# 总结:
	##	1) du -h 	# 常用	 
	##	2) du -m	# 当文件容量不足1MBytes时,向上取整,如: 文件目录容量为206KB,du -m 后显示 1MB
	##	3) du -s 	# 在同一目录下,  -s 的结果数 = -S 的结果数相加之和 

	# 3、 stat  获取文件inode信息
	# 语法:
	## 	stat 文件路径名		# 获取文件的inode信息(文件名,文件inode信息,文件的权限,所有者的UID和所属GID,以及文件的创建时间、修改时间...)

	#stat执行结果中的参数
	## Access：atime 表示我们最后一次访问（仅仅是访问，没有改动）文件的时间
	## modify：mtime 表示我们最后一次修改文件的时间
	## change：ctime 表示我们最后一次对文件属性改变的时间，包括权限，大小，属性等等。
	# 总结:
	## 	1) Modify的时间不能单独发生改变,只要Modify时间改变了,其他两个的时间必定发生改变
	##	2) 文件系统有文件实际内容和文件属性两部分,两部分数据一般分别存放在不同的区块，权限与属性存放在 inode 中，至于实际数据则放置到 data block 区块中。另外，还有一个超级区块（superblock）会记录整个文件系统的整体信息，包括 inode 与 block 的总量、使用量、剩余量等。
	##	3) stat -c ''

	# 4、 fdisk	linux系统磁盘分区格式化
	# 语法:
	# 	fdisk [-l] 装置名称	# fdisk -l : 输出后面接的装置所有的分区内容,只有指定 -l 才输出所有分区内容
	#
	# 例子:
	##	fdisk /dev/hdc		# 获取分区内容
	###			注:	 m: 获取参数帮助; 
	###				 w: 保存所有动作(即更改记录);
	###				 q: 退出,并不保存任何动作(即更改记录);
	###				 p: 可以列出目前这颗磁盘的分割表信息，这个信息的上半部在显示整体磁盘的状态


	# 5、mkfs	磁盘格式化
	# 语法:
	##	mkfs [-t 文件系统格式] 装置文件名	# 磁盘格式化; -t (type): 指定文件系统格式(当前系统支持的)
	#
	# 总结:
	##	1) mkfs[tab][tab]	# 即 mkfs + 按2次tab键, 可查看当前系统所支持的文件系统格式
	

	# 6、fsck	磁盘检验,用于检验和维护不一致的文件系统 
	# 语法:	
	##	fsck [-t 文件系统] [option] 装置名称	# 检验磁盘
	# 常用参数:
	##	-t : 给定档案系统的型式，若在 /etc/fstab 中已有定义或 kernel 本身已支援的则不需加上此参数
	##	-s : 依序一个一个地执行 fsck 的指令来检查
	##	-A : 对/etc/fstab 中所有列出来的 分区（partition）做检查
	##	-C : 显示完整的检查进度
	##	-d : 打印出 e2fsck 的 debug 结果
	##	-p : 同时有 -A 条件时，同时有多个 fsck 的检查一起执行
	##	-R : 同时有 -A 条件时，省略 / 不检查
	##	-V : 详细显示模式
	##	-a : 如果检查有错则自动修复
	##	-r : 如果检查有错则由使用者回答是否修复
	##	-y : 选项指定检测每个文件是自动输入yes,在不确定那些是不正常的时候,可以执行 # fsck -y 全部检查修复。
	##
	# 总结:
	##	1) fsck -C -f -t ext3 /dev/hdc6 	# 强制检测 /dev/hdc6 分区(该分区文件系统为 ext3); 注: 若文件系统不曾出现问题，检查的经过非常快速！若加上 -f 强制检查，才会一项一项的显示过程; (-f 表示强制执行)
	##	2) fsck[tab][tab]	# fsck + 按两次tab键, 查看并列出系统中所有支持fsck命令 的文件系统 


	# 7、 mount	 将文件挂载指定挂载点(挂载点:文件分区的入口);
	# 语法:	
	##	mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n]  装置文件名  挂载点
	##
	# 总结: 
	##	1) 挂载方式: 共两种,临时挂载和永久挂载;此命令为临时挂载,永久挂载需将挂载配置写入守护进程
	##	2) mount /dev/hdc6 /mnt/hdc6 		# 将装置/dev/hdc6(分区名) 挂载到 /mnt/hdc6 文件上面


	# 8、 umount 	卸除挂载点的装置(即关闭这个分区入口)
	# 语法:	
	##	 umount [option] 装置文件名或挂载点	# 卸除文件的挂载
	##
	# 常用参数:
	##	-f	强制卸除,可用在类似网络文件系统 (NFS) 无法读取到的情况下	
	##	-n	不升级/etc/mtab 的情况下卸除
	##
	#
	# 总结:
	##	1) umount /dev/hdc6	# 卸除装置 /dev/hdc6,此处/dev/hdc6位装置名(分区名)
	##	2) 
	
	
################------- 3、vim命令笔记 -------############# 
	vim命令笔记 
	 三种模式:
			类型		进入模式的命令	  标志(现象)
		1) 命令模式		vim 文件名		进入到文件内部
		2) 输入模式		i,o,a 			窗口左下角出现 --insert-- 或 --插入--
		3) 底线命令模式		:			窗口左下角出现 : 


	 1、命令模式: <j> 表示 j 键(需要区分的地方使用,默认字符不使用)

	# 	命令		功能
	# 屏幕移动	
	##	Ctrl + <f>	屏幕向下移动一页,相当于PageDown
	##	Ctrl + <b>	屏幕向上移动一页,相当于PageUp
	##	Ctrl + <d>	屏幕向下移动半页,down
	##	Ctrl + <u>	屏幕向上移动半页,up
	##
	##	>>		缩进	
	##	<<		取消缩进


	# 光标移动
	##	n<j>		光标向下移动 n 行,相当于 n + 方向下键; (h --左, j --下, k --上, l --右)
	##	n<空格>	光标向后(右)移动n个字符,若本行字符不足,则继续移动到下一行, 如: 10+<空格> # 光标后移10个字符
	##	+		光标移动到下一行(实测:下一行可为空格行)
	##	-		光标移动到下一行
	##	0		光标移到本行第一个字符处,等同于<Home>
	##	$		光标移到本行最后一个字符处,等同于<End>
	##	H		光标移动到屏幕最上方那行的第一个字符处	
	##	M		光标移动到屏中间那行的第一个字符处	
	##	L		光标移动到屏幕最下方那行的第一个字符处	
	##	G		光标移动到 文件最后一行; 先用 :set nu 显示文件行号
	##	n<G>		光标移动到 文件 第 n 行
	##	gg		光标移动到 第一行
	##	n<Enter>	光标向下移动 n 行	

	# 搜索替换 (向上向下,是相对于光标而言)
	##	/ding		向下搜索字符ding;
	##	?ding		向上搜索字符ding;
	##	<n> 		下一个搜索的字符(沿着搜索方向:/ 搜索时,向下; ? 搜索时,向上)
	##	<N> 		上一个搜索的字符(沿着搜索方向)
	##	:m,n<s>/findStr/replaceStr/g	在第 m 行 到 第 n 行之间区域,查找findStr ,并将其替换成replaceStr; 例如: :10,20s/'666'/'777'/g	# 将第10行到第20行区域内的字符'666'全都替换成'777'
	##	
	##	:1,$s/findStr/replaceStr/g	# 全文替换:从第1行到最后一行搜索findStr,并替换成replace	
	##
	##	:1,$s/findStr/replaceStr/gc	# 全文替换:从第1行到最后一行搜索findStr,并替换成replace, c confirm 每次替换需要用户确认,若有五次替换,需要五次确认,确认过才替换

	
	# 删除
	##	x		向后删除一个字符,(实测: 删除当前光标位置的字符)
	##	X		向前删除一个字符
	##	n<x>		连续向后删除 n 个字符(从当前位置开始,包含当前位置),n表示删除字符个数
	##	n<X>		连续向前删除 n 个字符,(不包含当前位置)
	##	dd		删除当前行
	##	n<d><d>		同时删除 n 行,n表示行数;如: 10dd 表示删除10行(当前行向下数)
	##	<d>n<G>		n 为数字,删除第 n 行; n=1表示文件第一行,n=G表示文件最后一行	
	##	dG		删除 当前行 到 文件最后一行的内容
	##	d$		删除当前行(的当前字符到行尾)部分,包含当前字符
	##	d0		删除当前行(的当前字符到行首)部分,不包含当前字符

		
	# 复制
	##	yy		复制当前行内容
	##	n<y><y>		n为行数,复制 n 行(从当前行开始往下数)内容
	##	<y>n<G>		n为行号,复制第 n 行内容		
	##	yG		复制当前行到文件最后一行的内容
	##	y0		复制光标到行首的内容,不包含当前字符
	##	y$		复制光标到行尾的内容,包含当前字符
	

	# 粘贴
	##	p		向下粘贴;例如: 光标在第20行处, 10yy 复制了10行; 按下p,则粘贴内容从第21行开始,截止到第30 行,原第20行之后的内容,均向后移动10行 (如: 原第 21 行~第 30 行向后移动,变成第31~40行)
	##	P		向上粘贴;结果类似 p 
	##	J		将当前行和下一行 合并成一行(并用空格分隔当前行和下一行的内容);例如:在第 20行 执行 J  ,则会将第21 行内容合并到 第 20 行行尾,同时用 空格隔开两行内容
	##	c		重复删除多个数据, 例如向下删除 10 行: 10cJ 或 10c+<方向下键>
	##	u		撤回,复原前一个动作
	##	<Ctrl>r		重复上一个动作
	##	.		口水点,重复上一个动作;  注: 只重复动作,不重复内容,如上一步是在第20行4dd(删除了第21~24行),当把光标移动第31行,会把第31~34行删除


	# 2、编辑模式(输入模式,取代模式)
	#
	#	命令		功能
	#	
	# 进入输入模式
	##	i		从当前光标处输入
	##	I		从当前行的第一个非空字符处输入
	##	a		当前位置的下一个字符处输入
	##	A		当前行最后一个字符处输入
	##	o		当前行的下一行输入,并另起一行; 例如: 当前行为第20行,输入o,会在原地20行和第21行之间新建一行,为新的第21行,原第21行变为第22行,且原行号大于等于21行的均向下移动一行 
	##	O		当前行的上一行输入,插入新的一行; 例如: 当前行为第20行,输入O,会在原地19行和第20行之间新建一行,为新的第20行,原第20行变为第21行,且原行号大于等于20行的均向下移动一行  	


	# 进入取代模式
	##	r		只会取代当前位置的字符一次; 注:先按<r>, 再输入替代的字符					
	##	R		会不断地取代当前位置的字符,直到按下<Esc>取消; 注: 先按<R>,再按替代的字符,只作用于当前行,不会自动跳转到下一行
	##	<Esc>		退出当前模式(编辑模式/底部命令模式),回到命令模式
	##
	##
	# 注意:
	##	1) 输入模式时,左下角会出现 '-- Insert --' 或 '-- 插入 --'  标志
	##	2) 替代模式时,左下角会出现 '-- Replace --' 或 '-- 替代 --'  标志


	# 3、底部命令模式(均以:开头)
	#	命令		功能

	# 保存,退出
	##	:w		将数据保存到硬盘中
	##	:w!		强制保存(一般用于只读权限时写入操作)
	##	:q		退出当前文件(离开vim 界面)
	##	:q!		强制退出(一般用于离开时,不保存修改记录)
	##	:wq		保存文件,并离开
	##	ZZ		若文件有更改,则保存更改并离开,若没有更改,则不保存并离开

	# 同时操作其他文件
	##	:w [filename]	将编辑的数据保存到另一个文件中(filename); 注: [] 表示可选参数,若filename 参数存在,则操作指定文件(fileaname),若无参数时则保存当前文件
	##	:r [filename]	在当前文件中,插入另一个文件(filename)的数据,插入位置为当前位置的下一个字符处; r--read;  注: [] 表示可选参数,若filename 参数存在,则操作指定文件(fileaname),若无参数时则默认操作当前文件
	##	:m,n <w> [filename]	将第m 行到第 n 行的内容写入filename 这个文件中
	##	:! command	暂时离开当前vim界面,进入linux命令界面,执行command命令,并显示执行结果,按任意键,返回vim界面
	##	:set nu		显示当前文件的所有行号
	##	:set nonu	隐藏当前文件的所有行号	
	##
	# 注意:
	##	1)  ! 		# 表示强制 (在vim 窗口) 
	##	2) :r [filename]  	# [] 表示可选参数,若filename 参数存在,则操作指定文件(fileaname),若无参数时则默认操作当前文件
	##	3) :w [filename]  	# [] 表示可选参数,若filename 参数存在,则操作指定文件(fileaname),若无参数时则保存当前文件
	##	4) vim命令中的 n 多为数字,表示行数 或 具体行号(第几行), 如: ndd -- 删除n行; dnG -- 删除第n 行
	##	5) 笔记中的涉及位置和方向的描述(当前位置,当前行,向下,向上...) 均是以光标所在位置作为参照


################------- 3、yum命令及安装 -------############# 
	 yum命令及安装 
	1、yum: 包依赖管理工具(基于RPM包管理),可以解决复杂的安装包依赖关系(例如: 安装A包,需要B包的支持,安装B包,需要C包的支持,成为A依赖B,B依赖C; 但是yum只需要安装A包就可以,因为yum会自动在安装A包之前去安装C,B包,所以程序员用yum只需要安装一个A包即可)

	2、语法:	yum [option] [command] [package]	
	常用参数:
		option: 可选; -h (帮助); -y (安装过程提示选择全部为'yes'); -q (不显示安装的过程) 等等
		command: 要进行的操作
		package: 要下载的安装包/软件名

	3、yum命令(常用的一些)
		1) yum check -update	# 列出所有可更新的软件列表
		2) yum update			# 更新所有软件
		3) yum install packageName	# 安装指定的软件packageName
		4) yum update packageName	# 更新指定的软件packageName
		5) yum list [rules]			# 列出所有可安装的软件列表, 支持正则规则(可选参数)
		6) yum remove packageName	# 删除指定的软件packageName
		7) yum search keyWords		# 查找软件包(根据关键字keyWords)		 

	 4、 清除缓存命令	
		1) yum clean packages	# 清除缓存目录下的软件包
		2) yum clean headers	# 清除缓存目录下的headers
		3) yum clean oldheaders	# 清除缓存目录下旧的headers
		4) yum clean [all] 		# all为可选字符,清除缓存目录下的软件包和旧的headers; 注: 相当于 yum clean packages; 加上 yum clean oldheaders 

	5、yum命令例子:
		1) yum install php	# 安装php软件
		2) yum remove php	# 删除php软件
		3) yum list php*	# 正则查找软件名以php开头的软件名列表

	6、
	# 国内yum源 (见菜鸟教程/百度)
	# 配置本地yum仓库 (见菜鸟教程/百度)





八、实践总结
	1、 expr , $[] , let 的区别
	 相同点: 
		 1)都是整数数值运算,不涉及小数运算; 注意: 是数值计算,而不是数字计算
	 不同点:
		 1) ``和$()用法一致,都可以解析linux命令,即`expr ` 和 $(expr )的语法一致,是expr运算的两种不同写法,expr 必须借助 `` 或者 $()
		 2) expr 乘法写法 \* (必须转义),且操作数和算术符号间必须以空格间隔,如: product=`expr $var1 \* $var2`;
		 3) expr 中的变量必须使用 $ 符号,如: sum=`expr $var1 + $var2`;  
		 错误写法: 
			sum=`expr var1 + var2`;
		 4) $[] 和 let 的乘号和除号都不能使用转义符号,否则报错,错误写法如:
			product=$[$var1\*$var2]; 
			division=$[$var1\/$var2];  
			let product=$var1\*$var2;  
			let division=$var1\/$var2;
		 5) $[] 和 let 中, 变量可用$,也可不用$; 操作数和算术符号间可以有空格,也可以没有空格,但是let 使>用空格时,必须将算术操作用()包裹,否则报错,如: let sum=$var1+$var2;
		 错误写法: 
			let sum=$var1 + $var2;  ## 先执行赋值操作
	2、`` 和 $() 的区别:
		1)  `` 和 $() 都表示 命令替换,返回linux命令执行结果
		2) `` 嵌套太多层会出问题，$() 嵌套多层没问题
		3) 所有类unix系统都支持 `` ，需要安装插件才能使用 $() (使用lnmp安装包默认安装了插件)
		4) `` 和 $() 中每个运算字符间都有空格,且算术运算时,$(),`` 都必须使用expr关键字,且 乘法 \* (转义)
		5) 注意: $(),``,eval都用于解释linux命令

	3、$(())
		1) 进制转换(指定进制数转化为十进制数),格式： $((N#num))，N表示进制格式,如2进制，3进制，8进制，11进制，16进制;num表示该进制的数值,$((8#110));	即表示:将8进制的110转换为十进制数,结果为72
		# 例子 echo $((2#110)); # 输出:6;将二进制转换为十进制
		# 例子 echo $((8#110)); # 输出:72;将八进制转换为十进制
		# 例子 echo $((11#110)); # 输出:132;将11进制转换为十进制

	4、(()) 
		1) 重定义变量值
		2) $? 表示最后一条命令执行结果反馈(返回值);当命令执行成功返回0，失败返回非0值(一般失败返回1)
			# 例1：a=5;b=7 
			# 	((a++))
			#	echo $a			# 输出：6
			#	((a--));echo $a		# 输出：5
			#	((a<b));echo $?		# 输出：0， 备注：linux中没错误返回0,
			#	((a>b));echo $?		# 输出：1
	5、$@ 和 $* 的区别:
		$* 相当于传递了一个由多个参数拼接后的字符串, $@相当于传递了多个参数字符串

	6、换行,转移符号 \ :
		 1) \ 转义符号,转义后的字符解析器不再解析
		 2) shell文件中,换行符号和 分号,都表示当前行命令到此截止
		 3) do后只能使用换行符号, 不得用分号结束
			实例1：
				echo "-----\$* 实例----------";
				for i in "$*"
				do
					echo $i
				done
			
			实例2：
				echo "-----\$@ 实例----------";  
				for i in "$@";
				do			
					echo $i;
				done;
	7、linux的管道:
		1) 无名管道: 用于父进程和子进程间的通信; 
		2) 有名管道: 用于同一系统任意两个进程间通信
	
	8、touch , echo , 和 vim 一个文件名(可能是不存在的文件)的区别
		1) touch 文件1 文件2	# 只创建文件,不写入内容,即创建空文件;可同时创建多个空文件
		
	9、exit	可在shell脚本中打断点
			
八、实践中的命令
	1、date命令
		1) date +%Y%m01 00:00:00	   # 获取当月1号凌晨
		2) date +%Y-%m-%d %H:%M:%S    #显示当前天,年-月-日 时:分:秒
		3) date -d "-1 month 2018-03-22" +%s    #显示2018-03-22上个月的22号的时间戳;存在一个漏洞: 当03-31号,>此操作无法获取上月天数,因为2月没有31号,此时返回03-01    

		4) date -d "+1 day" +%Y%m%d   #显示前一天的日期 
		5) date -d "-1 day" +%Y%m%d   #显示后一天的日期 
		6) date -d "-1 month" +%Y%m%d #显示上一月的日期 
		7) date -d "+1 month" +%Y%m%d #显示下一月的日期 
		8) date -d "-1 year" +%Y%m%d  #显示前一年的日期 

	2、判断函数是否已经定义:	
		1) type 变量名;		# 判断一个变量是否是特殊类型(alias、keyword、function、builtin、file),或者什么都不是,特殊类型返回类型名,否则返回空
		2) type[-t] 'addUser';		# 若addUser是函数名,则返回整个函数内容,否则返回>为空; 如: addUser is a function addUser() { echo '创建用户' }

	3、history 命令
		1) history		# 获取当前窗口的命令执行历史记录(升序排列)
		2) !! 			# 执行上一条命令,即history出来的最后一条命令
		3) !n			# 执行序号为 n 的命令,n为整数,如: !1000  ##执行序号为1000的命令记录
	
	4、awk 文本命令(awk还可用于浮点数计算)
		command1=`ps -ef | grep "ssh"`;	# 获取进程名含有 ssh字符的进程
		command2=`ps -ef | awk 'NR==3 {print $2}'`;	# 筛查出第3行,第2列的元素
		command3=`ps -ef | grep "ssh" | awk 'NR==2 {print $2}'`;	
		
	5、str=$(ps -ef | grep -c "ssh");  # $()解释括号中的命令,查看进程信息,同时匹配到含有ssh字符串的进程名数量
	
	6、tail -f /var/log/20181025.log	# 追踪文件内容,实时地在终端输出文件内容(即实时动态在linux界面打印文件内容)
	
	7、 awk 中的 for循环
		1) echo `awk 'BEGIN{for(a=1;a<=10;i++) print a}'`;	 # 命令行未解析，被当做字符串输出
		2) echo $(awk 'BEGIN{for(a=1;a<=10;i++) print a}'); # 命令行未解析，被当做字符串输出
		3) echo "awk 'BEGIN{for(a=1;a<=10;i++) print a}'";	# 命令行未解析，被当做字符串输出
		4) awk 'BEGIN{for(a=1;a<=10;i++) print a}'	# 直接在shell命令窗口执行此行命令
	
		5) 注意:
			linux中严格区分大小写，是BEGIN，而非begin

	8、read命令作用：
		1) 从标准输入中读取一行，并把输入行的每个字段的值指定给shell变量

	   2)常用参数	功能
		-a		# 后跟一个变量，该变量会被认为是个数组，然后给其赋值，默认是以空格为分割符。
		-d		# 后面跟一个标志符，其实只有其后的第一个字符有用，作为结束的标志，会举例说明。
		-p		# 后面跟提示信息，即在输入前打印提示信息。
		-e		# 在输入的时候可以时候命令补全功能。
		-n	 	# 后跟一个数字，定义输入文本的长度，很实用。
		-r	 	# 屏蔽，如果没有该选项，则作为一个转义字符，有的话 就是个正常的字符了。
		-s	 	# 安静模式，在输入字符时不再屏幕上显示，例如login时输入密码。
		-t	 	# 后面跟秒数，定义输入字符的等待时间。
		-u	 	# 后面跟fd，从文件描述符中读入，该文件描述符可以是exec新开启的。

			